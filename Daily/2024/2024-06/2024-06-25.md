---
Created: 2024-06-25
tags:
  - Algorithms
  - 자료구조
topic: 
parent_dir: Daily
categories:
---
# 06 스택
## 01 스택이란?
**생활 속의 스택**
스택이란 가장 뒤에 들어온 것이 가장 먼저 나가는 구조
```
스택: (LIFO - Last-In-First-Out)
큐: FIFO - First In, First Out
```

**스택의 개념과 원리**
스택의 맨 위 원소를 스택 탑, 스택 탑 원소라고 한다. 
프로그램이 이런 가상 메모리에서 수행된다는 가정하에 컴파일러가 컴파일하고 물리적인 메모리에는 수행시점에 대응된다. 

![[Screenshot 2024-06-25 at 15.16.55.png]]
**정적 영역**:
- 프로그램의 실행 코드와 프로그램이 끝날 때까지 없어지지 않는 데이터(전역 변수, 정적 변수) 등이 포함됨.
**동적 영역**:
- 프로그램 실행 중 할당받는 메모리인 힙 영역과 완료되지 않은 함수가 다른 함수를 호출할 때의 정보를 저장하는 스택 영역으로 나뉨.
- 힙: 사용자가 직접 할당받는 메모리 (예: Java의 new, C의 malloc())
- 스택: 활성 상태의 함수와 관련된 파라미터와 변수들.

**추상 데이터 타입 스택**
스택의 ADT
![[Screenshot 2024-06-25 at 15.24.30.png]]

## 02 배열을 이용한 스택
**배열 스택의 작업**
**원소 삽입**
1. **원소 삽입 위치 결정**: 스택 탑 인덱스를 1 증가시킨다.
2. **원소 저장**: 증가된 인덱스 위치에 새 원소를 저장한다.

**원소 삭제**
1. **원소 삭제**: 현재 스택 탑 인덱스 위치의 원소를 삭제한다.
2. **스택 탑 인덱스 감소**: 스택 탑 인덱스를 1 감소시킨다.

**popAll() 에서 배열을 교체한 이유**
- 기존방식: popAll() 메서드는 단순히 topIndex 를 -1로 리셋하는 방식
	- 문제점: 스택이 차지하고 있는 메모리를 완전히 해제하지 않아 메모리 누수 가능성
- 새로운 방식: 새로운 배열을 생성하여 기존 배열로 교체
	- 장점: 기존배열의 메모리를 완전히 해제가능. 메모리 누수 방지.
## 03 연결 리스트를 이용한 스택
**연결 리스트 스택의 객체구조**
1) `연결리스트`
	1) 연결 리스트로 구현하고
	2) 연결 리스트의 어느 쪽을 스택 탑으로 사용할지 결정 필요
2) `레퍼런스 변수`
	1) `topNode` 가 스택의 탑 노드를 가리킴
	2) 빈 스택은 `topNode` 가 null 을 가리킴

**원소삽입**
1) 스택에 원소 삽입할 때는 무조건 맨 위에 놓는다.
2) 맨 앞에 삽입이후 스택 탑 레퍼런스를 새 노드로 바꿔놓는다. 

> 배열 스택에서는 삽입 시 스택이 꽉 차 있으면 삽입을 못 했는데 
> 연결 리스트 스택에서는 노드를 만들어 붙이므로 삽입을 못하는 경우는 없다. 
>
>연결 리스트를 스택에서 사용할 때는 원소 삽입이 맨 앞에서만 일어난다.
>따라서 굳이 더미 헤드 노드를 만들 필요가 없다.

**원소삭제**
맨 앞 노드인 스택 팝 원소를 삭제하고 스택 탑 레퍼런스가 원래 탑 노드의 다음 노드를 가리키도록 한다.

**기타작업**
스택을 완전히 비울 때는 스택 탑 레퍼런스를 null 로 되돌리면 간단히 끝남.
-> 스택으로 사용된 연결 리스트는 청소가 가능!

## 04 다른 클래스를 재사용한 스택
**클래스 ‘연결 리스트’ 상속**
- 이미 만들어진 LinkedList 클래스를 상속받아 재사용하여 구현 노력을 줄임.
- 상위 클래스 생성자 호출: super() 키워드를 사용하여 상위 클래스인 LinkedList의 생성자를 호출.
- 메서드 재사용: 상위 클래스의 메서드를 재사용하고 필요시 오버라이드 가능.

**ADT 리스트 사용**
•	객체 내부의 메서드를 통해 리스트를 직접 접근하지 않고 간접 접근.
•	리스트 인터페이스 사용: ADT 리스트를 구현한 클래스를 연결하여 사용.

**정리**
•	상속을 통해 기존 클래스의 기능을 재사용하여 효율적으로 새로운 클래스를 구현.
•	상위 클래스의 메서드를 명시적으로 호출할 때 super 키워드를 사용.
•	ADT 리스트를 사용하여 스택 구현 시 리스트를 직접 접근하지 않고 메서드를 통해 접근.

## 05 스택 응용
**문자열 뒤집기**
- String 타입은 문자의 배열이 아닌 클래스이기 때문에 `s[i]`와 같이 접근이 불가능
- 대신 String 클래스에서 제공해주는 `s.charAt(i)` 로 문자를 하나씩 확인

**Postfix 계산**
- 타입 String 은 java.lang 에 있는 클래스라 따로 import 할 필요없이 그냥 쓰면 된다
- 클래스 String 에는 메서드 charAt() 이 제공되는데 이것은 문자열의 i번 문자를 리턴한다

1) 앞의 문자가 숫자이면 연속된 숫자로서 하나에 속하므로 스택 탑에 저장된 수를 뽑아서(pop()) 합쳐 계산한 다음 스택에 다시 넣어준다(push())
2) 문자가 연산자이면, 스택의 맨 위에 있는 수 2개를 뽑아서(pop() 2번) 계산한 다음 결과를 스택에 삽입한다(push())
3) 문자가 공백이면 무시한다. 

## 연습문제
01. 다음 후위 표현법의 식을 스택을 이용해 계산하는 과정에서 스택의 상태 변화를 설명해보시오. (단, 15와 25는 각각 한 번에 정수로 읽어들인다고 가정한다.)
```java
15 25 + 10 2 * -
```

02. 본문에서 ADT 리스트를 재사용하는 스택을 구현할 때 리스트의 맨 앞을 스택의 탑으로 간주했다. 반대로 리스트의 맨 끝을 스택의 탑으로 간주하여 다음 ListStack 코드를 바꾸어보시오. 참고로 리스트 인터페이스는 다음과 같다. 단, 임의의 특정 타입이라 생각하고 틀을 그대로 쓴다.
```java
public interface ListInterface {
    public void add(int i, E x);
    public int index(E x);
    public E get(int i);
    public void remove(int i);
    public void clear();
    public int len();
    public boolean isEmpty();
}
```

```java
public class ListStack implements StackInterface {
    private ListInterface list;
    public ListStack() {
        list = new LinkedList();  // ArrayList()를 사용해도 무방
    }
    public void push(E newItem) {
        list.add(1, newItem);
    }
    public E pop() {
        E x = list.get(1);
        list.remove(1);
        return x;
    }
    public E top() {
        return list.get(1);
    }
    public boolean isEmpty() {
        return list.isEmpty();
    }
    public void popAll() {
        list.clear();
    }
}
```

03. 