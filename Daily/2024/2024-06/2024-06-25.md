---
Created: "2024-06-25"
tags: 
topic: 
parent_dir: Daily
---
# 06 스택
## 01 스택이란?
**생활 속의 스택**
스택이란 가장 뒤에 들어온 것이 가장 먼저 나가는 구조
```
스택: (LIFO - Last-In-First-Out)
큐: FIFO - First In, First Out
```

**스택의 개념과 원리**
스택의 맨 위 원소를 스택 탑, 스택 탑 원소라고 한다. 
프로그램이 이런 가상 메모리에서 수행된다는 가정하에 컴파일러가 컴파일하고 물리적인 메모리에는 수행시점에 대응된다. 

![[Screenshot 2024-06-25 at 15.16.55.png]]

**정적 영역**:
- 프로그램의 실행 코드와 프로그램이 끝날 때까지 없어지지 않는 데이터(전역 변수, 정적 변수) 등이 포함됨.

**동적 영역**:
- 프로그램 실행 중 할당받는 메모리인 힙 영역과 완료되지 않은 함수가 다른 함수를 호출할 때의 정보를 저장하는 스택 영역으로 나뉨.
- 힙: 사용자가 직접 할당받는 메모리 (예: Java의 new, C의 malloc())
- 스택: 활성 상태의 함수와 관련된 파라미터와 변수들.

**추상 데이터 타입 스택**
스택의 ADT
![[Screenshot 2024-06-25 at 15.24.30.png]]

## 02 배열을 이용한 스택
**배열 스택의 작업**
**원소 삽입**
1. **원소 삽입 위치 결정**: 스택 탑 인덱스를 1 증가시킨다.
2. **원소 저장**: 증가된 인덱스 위치에 새 원소를 저장한다.

**원소 삭제**
1. **원소 삭제**: 현재 스택 탑 인덱스 위치의 원소를 삭제한다.
2. **스택 탑 인덱스 감소**: 스택 탑 인덱스를 1 감소시킨다.

**popAll() 에서 배열을 교체한 이유**
- 기존방식: popAll() 메서드는 단순히 topIndex 를 -1로 리셋하는 방식
	- 문제점: 스택이 차지하고 있는 메모리를 완전히 해제하지 않아 메모리 누수 가능성
- 새로운 방식: 새로운 배열을 생성하여 기존 배열로 교체
	- 장점: 기존배열의 메모리를 완전히 해제가능. 메모리 누수 방지.
## 03 연결 리스트를 이용한 스택
**연결 리스트 스택의 객체구조**
1) `연결리스트`
	1) 연결 리스트로 구현하고
	2) 연결 리스트의 어느 쪽을 스택 탑으로 사용할지 결정 필요
2) `레퍼런스 변수`
	1) `topNode` 가 스택의 탑 노드를 가리킴
	2) 빈 스택은 `topNode` 가 null 을 가리킴

**원소삽입**
1) 스택에 원소 삽입할 때는 무조건 맨 위에 놓는다.
2) 맨 앞에 삽입이후 스택 탑 레퍼런스를 새 노드로 바꿔놓는다. 

> 배열 스택에서는 삽입 시 스택이 꽉 차 있으면 삽입을 못 했는데 
> 연결 리스트 스택에서는 노드를 만들어 붙이므로 삽입을 못하는 경우는 없다. 
>
>연결 리스트를 스택에서 사용할 때는 원소 삽입이 맨 앞에서만 일어난다.
>따라서 굳이 더미 헤드 노드를 만들 필요가 없다.

**원소삭제**
맨 앞 노드인 스택 팝 원소를 삭제하고 스택 탑 레퍼런스가 원래 탑 노드의 다음 노드를 가리키도록 한다.

**기타작업**
스택을 완전히 비울 때는 스택 탑 레퍼런스를 null 로 되돌리면 간단히 끝남.
-> 스택으로 사용된 연결 리스트는 청소가 가능!

## 04 다른 클래스를 재사용한 스택
**클래스 ‘연결 리스트’ 상속**
- 이미 만들어진 LinkedList 클래스를 상속받아 재사용하여 구현 노력을 줄임.
- 상위 클래스 생성자 호출: super() 키워드를 사용하여 상위 클래스인 LinkedList의 생성자를 호출.
- 메서드 재사용: 상위 클래스의 메서드를 재사용하고 필요시 오버라이드 가능.

**ADT 리스트 사용**
•	객체 내부의 메서드를 통해 리스트를 직접 접근하지 않고 간접 접근.
•	리스트 인터페이스 사용: ADT 리스트를 구현한 클래스를 연결하여 사용.

**정리**
•	상속을 통해 기존 클래스의 기능을 재사용하여 효율적으로 새로운 클래스를 구현.
•	상위 클래스의 메서드를 명시적으로 호출할 때 super 키워드를 사용.
•	ADT 리스트를 사용하여 스택 구현 시 리스트를 직접 접근하지 않고 메서드를 통해 접근.

## 05 스택 응용
**문자열 뒤집기**
- String 타입은 문자의 배열이 아닌 클래스이기 때문에 `s[i]`와 같이 접근이 불가능
- 대신 String 클래스에서 제공해주는 `s.charAt(i)` 로 문자를 하나씩 확인

**Postfix 계산**
- 타입 String 은 java.lang 에 있는 클래스라 따로 import 할 필요없이 그냥 쓰면 된다
- 클래스 String 에는 메서드 charAt() 이 제공되는데 이것은 문자열의 i번 문자를 리턴한다

1) 앞의 문자가 숫자이면 연속된 숫자로서 하나에 속하므로 스택 탑에 저장된 수를 뽑아서(pop()) 합쳐 계산한 다음 스택에 다시 넣어준다(push())
2) 문자가 연산자이면, 스택의 맨 위에 있는 수 2개를 뽑아서(pop() 2번) 계산한 다음 결과를 스택에 삽입한다(push())
3) 문자가 공백이면 무시한다. 

## 연습문제
01. 다음 후위 표현법의 식을 스택을 이용해 계산하는 과정에서 스택의 상태 변화를 설명해보시오. (단, 15와 25는 각각 한 번에 정수로 읽어들인다고 가정한다.)
```java
15 25 + 10 2 * -
```

1.	문자열 표현식을 공백을 기준으로 분리하여 토큰 배열을 만듭니다.
2.	각 토큰을 순서대로 처리합니다.
	•	숫자인 경우 스택에 push합니다.
	•	연산자인 경우 스택에서 두 개의 숫자를 pop하여 해당 연산을 수행하고, 결과를 다시 스택에 push합니다.
3.	모든 토큰을 처리한 후, 스택의 최상단 값이 최종 결과가 됩니다.
----
1. 15를 스택에 push합니다.
	• 스택 상태: [15]
2. 25를 스택에 push합니다.
	• 스택 상태: [15, 25]
3. + 연산자를 만나면, 스택에서 두 개의 피연산자를 pop하여 더한 다음 결과를 스택에 push합니다.
	• 25 (pop)
	• 15 (pop)
	• 결과: 15 + 25 = 40
	• 스택 상태: [40]
4. 10을 스택에 push합니다.
	• 스택 상태: [40, 10]
5. 2를 스택에 push합니다.
	• 스택 상태: [40, 10, 2]
6. * 연산자를 만나면, 스택에서 두 개의 피연산자를 pop하여 곱한 다음 결과를 스택에 push합니다.
	• 2 (pop)
	• 10 (pop)
	• 결과: 10 * 2 = 20
	• 스택 상태: [40, 20]
7. - 연산자를 만나면, 스택에서 두 개의 피연산자를 pop하여 뺀 다음 결과를 스택에 push합니다.
	• 20 (pop)
	• 40 (pop)
	• 결과: 40 - 20 = 20
	• 스택 상태: [20]

02. 본문에서 ADT 리스트를 재사용하는 스택을 구현할 때 리스트의 맨 앞을 스택의 탑으로 간주했다. 반대로 리스트의 맨 끝을 스택의 탑으로 간주하여 다음 ListStack 코드를 바꾸어보시오. 참고로 리스트 인터페이스는 다음과 같다. 단, 임의의 특정 타입이라 생각하고 틀을 그대로 쓴다.
```java
public interface ListInterface {
    public void add(int i, E x);
    public int index(E x);
    public E get(int i);
    public void remove(int i);
    public void clear();
    public int len();
    public boolean isEmpty();
}
```

```java
public class ListStack implements StackInterface {
    private ListInterface list;
    public ListStack() {
        list = new LinkedList();  // ArrayList()를 사용해도 무방
    }
    public void push(E newItem) {
        list.add(1, newItem);
    }
    public E pop() {
        E x = list.get(1);
        list.remove(1);
        return x;
    }
    public E top() {
        return list.get(1);
    }
    public boolean isEmpty() {
        return list.isEmpty();
    }
    public void popAll() {
        list.clear();
    }
}
```

- 정답
```java
public class ListStack<E> implements StackInterface<E> {
    private ListInterface<E> list;

    public ListStack() {
        list = new LinkedList<E>(); // You can use ArrayList as well
    }

    public void push(E newItem) {
        list.add(list.len() + 1, newItem); // 리스트 끝에 추가
    }

    public E pop() {
        E x = list.get(list.len()); // 마지막 요소 받아오기
        list.remove(list.len()); // 마지막 요소 지우기
        return x;
    }

    public E top() {
        return list.get(list.len()); // 마지막 요소 리턴
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void popAll() {
        list.clear();
    }
} 
```

03. [코드 6-4]는 가장 기본적인 연결 리스트를 사용하여 스택을 구현한 것이다. 이를 더미 헤드 노드를 가진 연결 리스트로 바꾸어보시오.
```java
package stack;
import list.Node;

public class LinkedStack<E> implements StackInterface<E> {
    private Node<E> dummyHead;
    private final E ERROR = null; // 임의의 에러 값

    public LinkedStack() {
        dummyHead = new Node<>(null, null); // Initialize dummy head node
    }

    // [알고리즘 6-7] 구현: 스택에 원소 x 삽입하기
    public void push(E newItem) {
        dummyHead.next = new Node<>(newItem, dummyHead.next);
    }

    // [알고리즘 6-8] 구현: 스택에서 원소 삭제하기
    public E pop() {
        if (isEmpty()) return ERROR;
        else {
            Node<E> temp = dummyHead.next;
            dummyHead.next = temp.next;
            return temp.item;
        }
    }

    // [알고리즘 6-9] 구현: 스택 탑 원소 알려주기
    public E top() {
        if (isEmpty()) return ERROR;
        else return dummyHead.next.item;
    }

    // [알고리즘 6-10] 구현: 스택이 비었는지 확인하기
    public boolean isEmpty() {
        return (dummyHead.next == null);
    }

    // [알고리즘 6-11] 구현: 스택 비우기
    public void popAll() {
        dummyHead.next = null;
    }
}
```

04. 스택을 이용해서 입력으로 들어온 문자열이 다음 집합의 원소인지 체크하는 코드를 작성하시오. 자바 코드에 구애받지 않고, 알고리즘의 의미가 통하도록 작성하면 된다.

>❓: 저 달러싸인은 뭐지? 원래 이런 집합표시가 있는건가?

```
{ w$wR | w: 문자열, wR: w의 순서를 뒤집어 놓은 것 }
```

05. [코드 6-2]의 배열 기반 스택 구현에서 스택의 모든 원소를 프린트하는 것은 개발 과정에서 유용할 때가 있다. [코드 6-2]에 스택의 모든 원소를 탐부터 시작하여 프린트하는 메서드 `printAll()`을 추가하시오. 편의상 가상 타입 E는 int 타입이라고 가정한다.


06. [코드 6-4]의 연결 리스트 기반 스택 구현에서 05번 문제와 같은 조건으로 메서드 printAll()을 추가하시오.

07. [코드 6-6]과 [코드 6-7]은 재사용을 통한 스택 구현 코드다. 각각의 코드에 05번 문제와 같이 메서드 printAll()을 추가하시오.

08. LinkedStack 타입의 객체 a의 내용을 그대로 또 다른 LinkedStack 타입의 객체 b로 복사하는 코드를 작성하시오. (a의 레퍼런스 값을 b로 복사하여 두 변수가 같은 레퍼런스를 가져 내용이 같아지도록 하라는 것이 아니라 내용을 복사하라는 것이다.) [코드 6-4]의 환경에서 작업한다.

09. [코드 6-2]의 클래스 ArrayStack에서 push()를 수행할 때 스택이 꽉 차 있으면 더 이상 push() 작업을 할 수 없다. 본문의 [코드 6-2]에서는 그 경우 에러 처리를 하도록 했다. 에러 처리를 하지 말고, 배열의 크기를 2배로 확장하여 배열의 내용을 새로 바꾼 배열로 복사한 다음 push()를 완료하는 코드를 작성하시오.

10. 단방향 연결 리스트가 있다고 하자. 리스트에서 맨 마지막 노드의 next 값은 null이다. 주어진 단방향 연결 리스트의 원소들을 역순으로 프린트하도록 스택을 이용하는 알고리즘을 자바 형태로 작성하려 한다. (스택을 이용해보는 연습이니 효율성 면에서 부자연스러울 수도 있다.) 다음 클래스 LinkedList의 printReverse()를 완성하시오. 1️⃣ 부분을 채우면 된다.
```java
public class Node {
    public E item;
    public Node next;
    
    public Node(E newItem) {
        item = newItem;
        next = null;
    }
    
    public Node(E newItem, Node nextNode) {
        item = newItem;
        next = nextNode;
    }
}

public class LinkedStack implements StackInterface {
    private Node topNode;
    
    public LinkedStack() {
        topNode = null;
    }
    
    public void push(E newItem) {
        topNode = new Node(newItem, topNode);
    }
    
    public E pop() {
        if (isEmpty()) { /* 에러 처리 */ }
        else {
            Node temp = topNode;
            topNode = topNode.next;
            return temp.item;
        }
    }
    
    public E top() {
        if (isEmpty()) { /* 에러 처리 */ }
        else return topNode.item;
    }
    
    public boolean isEmpty() {
        return (topNode == null);
    }
    
    public void popAll() {
        topNode = null;
    }
}

public interface ListInterface {
    public void add(int i, E x);
    public int index(E x);
    public E get(int i);
    public void remove(int i);
    public void clear();
    public int len();
    public boolean isEmpty();
    public void printReverse();
}

public class LinkedList implements ListInterface {
    private Node head;
    private int numItems;
    ...
    public void printReverse() {
        1️⃣ ⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️
    }
    ...
}

```