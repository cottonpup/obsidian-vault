---
Created: 2024-06-25
tags: 
topic: 
parent_dir: Daily
categories:
---
# 06 스택
## 01 스택이란?
**생활 속의 스택**
스택이란 가장 뒤에 들어온 것이 가장 먼저 나가는 구조
```
스택: (LIFO - Last-In-First-Out)
큐: FIFO - First In, First Out
```

**스택의 개념과 원리**
스택의 맨 위 원소를 스택 탑, 스택 탑 원소라고 한다. 
프로그램이 이런 가상 메모리에서 수행된다는 가정하에 컴파일러가 컴파일하고 물리적인 메모리에는 수행시점에 대응된다. 

![[Screenshot 2024-06-25 at 15.16.55.png]]
**정적 영역**:
- 프로그램의 실행 코드와 프로그램이 끝날 때까지 없어지지 않는 데이터(전역 변수, 정적 변수) 등이 포함됨.
**동적 영역**:
- 프로그램 실행 중 할당받는 메모리인 힙 영역과 완료되지 않은 함수가 다른 함수를 호출할 때의 정보를 저장하는 스택 영역으로 나뉨.
- 힙: 사용자가 직접 할당받는 메모리 (예: Java의 new, C의 malloc())
- 스택: 활성 상태의 함수와 관련된 파라미터와 변수들.

**추상 데이터 타입 스택**
스택의 ADT
![[Screenshot 2024-06-25 at 15.24.30.png]]

## 02 배열을 이용한 스택
**배열 스택의 작업**
**원소 삽입**
1. **원소 삽입 위치 결정**: 스택 탑 인덱스를 1 증가시킨다.
2. **원소 저장**: 증가된 인덱스 위치에 새 원소를 저장한다.

**원소 삭제**
1. **원소 삭제**: 현재 스택 탑 인덱스 위치의 원소를 삭제한다.
2. **스택 탑 인덱스 감소**: 스택 탑 인덱스를 1 감소시킨다.

**popAll() 에서 배열을 교체한 이유**
- 기존방식: popAll() 메서드는 단순히 topIndex 를 -1로 리셋하는 방식
	- 문제점: 스택이 차지하고 있는 메모리를 완전히 해제하지 않아 메모리 누수 가능성
- 새로운 방식: 새로운 배열을 생성하여 기존 배열로 교체
	- 장점: 기존배열의 메모리를 완전히 해제가능. 메모리 누수 방지.
## 03 연결 리스트를 이용한 스택
**연결 리스트 스택의 객체구조**
1) `연결리스트`
	1) 연결 리스트로 구현하고
	2) 연결 리스트의 어느 쪽을 스택 탑으로 사용할지 결정 필요
2) `레퍼런스 변수`
	1) `topNode` 가 스택의 탑 노드를 가리킴
	2) 빈 스택은 `topNode` 가 null 을 가리킴

**원소삽입**
1) 스택에 원소 삽입할 때는 무조건 맨 위에 놓는다.
2) 맨 앞에 삽입이후 스택 탑 레퍼런스를 새 노드로 바꿔놓는다. 

> 배열 스택에서는 삽입 시 스택이 꽉 차 있으면 삽입을 못 했는데 
> 연결 리스트 스택에서는 노드를 만들어 붙이므로 삽입을 못하는 경우는 없다. 
>
>연결 리스트를 스택에서 사용할 때는 원소 삽입이 맨 앞에서만 일어난다.
>따라서 굳이 더미 헤드 노드를 만들 필요가 없다.

**원소삭제**
맨 앞 노드인 스택 팝 원소를 삭제하고 스택 탑 레퍼런스가 원래 탑 노드의 다음 노드를 가리키도록 한다.

**기타작업**
스택을 완전히 비울 때는 스택 탑 레퍼런스를 null 로 되돌리면 간단히 끝남.
-> 스택으로 사용된 연결 리스트는 청소가 가능!

## 04 다른 클래스를 재사용한 스택


## 05 스택 응용
