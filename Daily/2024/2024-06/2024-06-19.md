---
Created: "2024-06-19"
tags: 
topic: 
parent_dir: Daily
---
# 쉽게 배우는 자료구조 with 자바
## 04 클래스
클래스는 객체 지향 언어의 `객체`를 만드는 수단이고 대표적 객체 지향 언어인 자바는 모든 것이 클래스를 중심으로 구성된다. 클래스는 어떤 대상을 추상화하는 의미 단위이기도 하다. 프로그램은 하나 이상의 클래스를 모아놓은 것이다. 

![[Screenshot 2024-06-19 at 22.29.42.png]]
## 05 리스트
**학습목표**
- 리스트의 직관적 의미를 이해한다.
- 배열로 만든 리스트를 이해한다. 
- 연결 리스트로 만든 리스트를 이해한다.
- 좀 더 고도화된 연결 리스트를 이해한다.
- 배열 리스트와 연결 리스트의 장단점을 이해하고, 상황에 따라 이들 중 선택할 수 있는 판단력을 기른다. 
---
### 01 리스트란
**리스트의 작업**
자료구조를 필요한 작업 목록으로 정의한 것 -> 추상 데이터 타입(ADT)
파이썬은 리스트를 기본 자료구조로 제공해줌!
반면, 자바에서는 리스트를 기본 자료구조로 제공하지 않고 `java.util` 패키지에서 제공한다.

**리스트의 구현**
리스트를 구현하는 두 가지 대표적인 방법
1. 배열에 원소를 쭉 배치하는 방법
2. 링크를 이용해 원소들을 연결하는 방법
   
![[Screenshot 2024-06-19 at 22.39.51.png]]

<배열을 이용한 리스트>
- 단순하고 편리하다.
- 리스트에 원소가 얼마나 들어올지 예상하기는 쉽지 않으므로 배열을 사용할 경우 충분한 공간을 확보해두고 작업을 시작해야하기 때문에 대체로 공간 낭비가 심하다.

<연결 리스트를 이용한 리스트>
- 배열의 공간 낭비를 피할 수 있는 자료구조
### 02 배열 리스트
[visualAlgo 배열](https://visualgo.net/en/array)

**배열 리스트의 객체구조**
리스트 객체에는 2개의 필드, 즉 원소들이 저장하는 배열 items[] 필드와 원소의 총 수를 저장하는 numItems 필드가 있다.
- items[]
- numItems

자바에서의 배열 리스트 필드와 작업의 의미
![[Screenshot 2024-06-20 at 12.50.38.png]]
**배열 리스트의 작업**
- 원소 삽입
	- add(0, x)
		- 우시프트를 해서 원소를 옮기고  numItems 값을 1 증가
	- 맨 뒤에 원소를 추가하는 작업을 할 때는 add(numItems, x)
- 원소 삭제
	- 좌시프트를 해서 원소를 옮기고 numItems 값을 1 감소
- 기타 작업
	- get()
	- set()
	- indexOf()
	- leng()
	- isEmpty()
	- clear()
#### 배열 리스트의 구현(원소 타입을 확정한 버전)
**리스트 인터페이스**
인터페이스 기능을 사용해 ADT 를 구체적으로 정의할 수 있다.
규모가 있는 프로그램을 작성한다면 인터페이스만 보고 사용하는 코딩 습관을 기르는 것이 좋다.

**배열 리스트 클래스 초기화**
- 예약어 `static` 의 바인딩
	- `static` 이 있으면 컴파일 시점에 상수가 생성된다. (정적 바인딩)
	- `static` 이 없으면 프로그램 수행 중에 새 객체가 생성될 때 상수가 생성된다. (동적 바인딩)
```java
public class IntegerArrayList implements IntegerListInterface {
    private Integer[] item;
    private int numItems;
    private static final int DEFAULT_CAPACITY = 64;

    public IntegerArrayList() {  // 생성자 1
        item = new Integer[DEFAULT_CAPACITY];
        numItems = 0;
    }

    public IntegerArrayList(int n) {  // 생성자 2
        item = new Integer[n];
        numItems = 0;
    }
}
```

**전체 코드**
`int` 는 기본 데이터 타입이고 `Integer` 는 그에 해당하는 객체 타입, 즉 래퍼 클래스

- 오토박싱(Auto-boxing)
	- 오토박싱은 자바에서 이런 기본 타입의 데이터를 자동으로 객체 타입으로 변환해주는 기능

### 03 연결 리스트
**연결 리스트의 객체 구조**
- 연결 리스트는 배열의 공간 낭비를 피할 수 있는 자료구조다. 
- 원소가 추가될 때마다 공간을 할당받아 추가하는 동적 할당 방식을 따르기 때문이다. 

연결 리스트의 노드는 원소를 저장하는 필드 item 과 다음 노드를 가리키는 필드 next 로 구성된다. 
필드 next 는 다음 노드를 가리키는 링크(자바의 레퍼런스)
![[Screenshot 2024-06-20 at 17.22.30.png]]

첫번째 노드를 가리키는 레퍼런스 head 가 있다.
#### 연결 리스트의 작업
##### 원소 삽입
연결 리스트에서 중간에 노드를 삽입하려면 삽입 노드의 바로 앞에 있는 노드, 즉 직전 노드를 가리키는 레퍼런스 prevNode 가 있어야 한다. 

원소를 삽입할 때 두 가지로 나누어 처리한다. 
- 원소를 중간에 삽입할 때
- 원소를 맨 뒤 혹은 맨 앞에 삽입하는 경우

*더미 헤드 노드를 넣는 경우*
이렇게 두 가지 경우로 나누지 않아도 되는 방법이 있다. 리스트의 맨 앞에 `더미 헤드 노드`를 하나 두면 된다.
더미 헤드 노드는 데이터를 저장하지 않고, 첫번째 노드를 가리키는 용도이다.
더미 헤드 노드 덕분에 리스트가 비어있을 때의 별도의 처리가 필요가 없다!
##### 원소 삭제
원소를 삭제할 때도 prevNode 가 필요!

### 04 배열 리스트와 연결 리스트의 비교


### 05 연결 리스트의 확장

### 연습문제
1. 연결 리스트 구현 시 더미 헤드를 사용하는 장단점을 말해보시오.
	<장점>
	- 리스트의 시작과 끝을 추가, 삭제할 때 코드가 간단해진다.
	- 경계조건 처리가 편해진다. (리스트가 비어있는 경우를 처리해주지 않아도 됨)

	<단점>
	- 초기 설정이 필요

2. 인터페이스 `java.util.List` 에는 원소 x가 존재하는지 체크해주는 메서드 `contains()` 도 요구하고 있다. 이것은 본문에서 소개한 메서드 `indexOf(x)` 를 호출해서 간단히 해결할 수 있습니다. 다음 1️⃣ 부분을 완성하시오.
```java
public boolean contains(E x) {
    1️⃣ ⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️⬛️
}
```

3. 2절에서 배열 item[0…n-1]을 리스트의 0 ~ n-1번째 원소에 대응시켰다. 배열 item[0…n-1]을 리스트의 1 ~ n번째(첫 원소를 1번째 원소라 부른다) 원소에 대응시키도록 하려 한다. [코드 5-2]의 IntegerArrayList 클래스에 대해 다음 물음에 답하시오.
	1. [코드 5-2]에서 수정되어야 할 메서드를 나열하시오.
	2. (가)에서 나열한 메서드를 각각 수정해보시오.

4. 배열로 구현된 리스트에서 i ~ j번째 원소(첫 원소는 0번째 원소라 부른다)를 프린트하는 메서드 `printInterval()`을 작성하시오. [코드 5-5]의 클래스 `ArrayList`에 메서드 `printInterval()`을 더하는 방식으로 하고 다음 ① 부분을 완성하시오. 로직에 집중하기 위해 배열 item[] 원소의 프린트는 `System.out.println(item[i])`로 쓰시오.

5. 4번 문제와 똑같은 작업을 [코드 5-9]의 LinkedList에서 하시오. 역시 클래스 LinkedList에서 메서드를 더하는 방식으로 하고 다음 ① 부분을 완성하시오. 노드 tNode의 원소의 프린트는 `System.out.println(tNode.item)`으로 쓰시오.

****