---
Created: 2024-06-10
tags:
  - 넥스트이노베이션
  - 자료구조
topic: 
parent_dir: Daily
---
# 자료구조
## Ch2 문제풀이
### 01. 다음 수열의 n번째 항을 구하는 재귀 알고리즘을 작성하시오.
 `a_n = 5a_{n-1} + 3, \, a_1 = 0 `
#### 정답 
```java
public class Sequence {
    public static int seq(int n) {
        if (n == 1) return 0;
        return 5 * seq(n - 1) + 3;
    }

    public static void main(String[] args) {
        int n = 5; // 예시로 5번째 항을 구해봅니다.
        System.out.println("seq(" + n + ") = " + seq(n));
    }
}
```
초항이 1, 공차가 5인 등차수열.
이전 항에 5를 곱하고 3을 더하여 다음 항을 구합니다.
### 02. 본문에서 소개한 다음 알고리즘에서 양의 정수 n에 대해 함수 seq()는 총 몇 회 호출되는가? 이때 최초의 호출 seq(n)도 포함하여 센다.
```python
seq(n):
	if (n = 1) return 1
	else return seq(n-1) + 3
```
#### 정답
n 번

단순한 선형 재귀. 
### 03. 다음 피보나치 수열을 구하는 재귀 알고리즘에서 5번째 피보나치 수를 구하는 fib(5)를 수행하면 함수 fib()는 총 몇 회 호출되는가? 이때 최초의 호출 fib(5)도 포함하여 센다. (이 문제는 fib()가 매우 불필요한 중복 호출이 심하다는 것을 느끼게 하려고 출제하였다.)
```python
fib(n):
    if (n = 1 or n = 2) return 1
    else return fib(n - 1) + fib(n - 2)
```
#### 정답
**`9번`**

피보나치 수열을 재귀적으로 계산할 때 중복호출이 많이 일어난다. 
호출 횟수는 피보나치 수열의 특성상 중복 호출이 많이 발생하여 매우 많아집니다.
n이 커질수록 호출 횟수가 기하급수적으로 증가합니다.

호출 횟수 계산:

	1.	fib(5) - 1회
	2.	fib(4) - 1회
	3.	fib(3) - 1회
	4.	fib(3) - 1회 (중복 호출)
	5.	fib(2) - 1회
	6.	fib(2) - 1회 (중복 호출)
	7.	fib(2) - 1회 (중복 호출)
	8.	fib(1) - 1회
	9.	fib(1) - 1회 (중복 호출)

각 호출을 세면 다음과 같이 됩니다:

	•	fib(5) 호출: 1회
	•	fib(4) 호출: 1회
	•	fib(3) 호출: 2회 (중복 호출 포함)
	•	fib(2) 호출: 3회 (중복 호출 포함)
	•	fib(1) 호출: 2회 (중복 호출 포함)

### 04. 다음 하노이 탑 재귀 알고리즘에 대해 5개의 원반을 옮기고자 move(5, a, b, c)를 수행하면 함수 move(n)는 총 몇 회 호출되는가? 이때 최초의 호출 move(5, a, b, c)도 포함하여 센다. (03번 문제처럼 피해 갈 수 있는데도 재귀를 통해 중복 호출을 하는 예도 있다. 이번 문제는 피해 갈 수 없지만 호출이 지수함수적으로 증가하는 하노이 탑 문제의 호출 횟수를 느껴보게 하려고 출제하였다.)
```python
move(n, a, b, c):
	if(n > 0)
		move(n - 1, a, c, b)
		%% 1️⃣. a에 있는 원반을 b로 옮긴다. %%
		move(n-1, c, b, a)
```
#### 정답
31 회 
점화식으로 표현하면 `2^n - 1`
### 05. 04번 문제에서 함수 move()의 호출 횟수 대신 1️⃣의 원반을 옮기는 행위의 총 횟수를 세어보시오. 이 횟수와 move()의 호출 횟수는 어떤 관계가 있는지 생각해보시오.
#### 정답
1️⃣의 원반을 옮기는 행위의 총 횟수는 2^n - 1입니다. 이는 move() 함수의 호출 횟수와 같습니다. 각 호출은 단일 원반의 이동과 연관되어 있습니다.
### 06. 04번 문제에서 다음처럼 경계 조건이 빠진 재귀 알고리즘이 수행되면 어떻게 되는가?
```python
move(n, a, b, c);
	move(n-1, a, c, b);
	a에 있는 원반을 b로 옮긴다
	move(n-1, b, a, c);
```
#### 정답
경계 조건이 빠진 경우 재귀 호출이 무한히 반복되어 스택 오버플로우가 발생합니다. 프로그램은 종료되지 않고 계속해서 재귀 호출을 수행합니다.
### 07. `알고리즘 2-6`의 선택 정렬 알고리즘에서 임의의 양의 정수 n에 대해 selectionSort(A, n)을 수행하면 함수 selectionSort()는 총 몇 회 수행되는가? 이때 최초의 호출 selectionSort(A, n) 도 포함하여 샌다. 
```python 
selectionSort(A[], n);         // 배열 A[0...n-1]을 정렬한다.
if (n > 1) {
    A[k]                               // <- A[n-1] 중 가장 큰 A 위치를 찾는다
    A[k]                               // <-> A[n-1] A[1]와 A[n-1]의 값을 교환한다.
    selectionSort(A, n-1)
}
```
#### 정답

### 08. 다음의 재귀적 표현에서 `<T>`는 무엇을 표현한 것인가?
```python
<T> = <A><T><A>
<A> = a | i | ... | g
```
#### 정답
여기서 <T>는 <A>로 시작하고 <T>가 다시 등장하며 <A>로 끝나는 구조입니다. <A>는 단일 문자(예: a, i, g)로 표현됩니다. 이는 특정 문자열 패턴을 생성하는 문법 규칙을 나타냅니다. 이 규칙에 따르면, <T>는 무한히 반복되는 <A>의 조합으로 표현됩니다.