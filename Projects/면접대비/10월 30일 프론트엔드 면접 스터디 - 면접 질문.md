## [ 리액트 ]

# 서버 사이드 렌더링 vs 클라이언트 사이드 렌더링
- **서버 사이드 렌더링**은 페이지의 내용을 서버에서 미리 만들어서 완성된 페이지를 사용자에게 보내줍니다. 이 방식의 장점은, **검색 엔진이 페이지의 내용을 쉽게 이해**할 수 있어서 검색 결과에 더 잘 나타날 수 있고, **초기 렌더링 속도가 빠릅**니다. 
- **클라이언트 사이드 렌더링**은 서버에서 미리 HTML만 보내주고, 실제 페이지의 내용은 사용자의 컴퓨터에서 만들어집니다. **초기 렌더링 속도가 느리지만**, 서버를 거치지 않고 클라이언트(브라우저)에서 처리하기 때문에 **사용자와의 상호작용이 더 빠르고** 부드럽습니다. (많은 사용자를 처리가능, SPA의 등장) 하지만 자바스크립트 코드로 되어있는 코드를 웹 크롤러가 읽지 못하기 때문에 **검색 엔진에 매우 취약**합니다.
## SPA의 장단점
SPA는 한 페이지에서 모든 내용을 동적으로 불러와서 표시하는 방식입니다. 
- 장점: 서버 부담 적음, 컴포넌트 개발 용이, 빠른 페이지 전환, 좋은 사용자 경험.
- 단점: 느린 초기 구동 속도, 검색 엔진 최적화 어려움
## SSR 컨텍스트에서 'hydration'이란 무엇인가요?
서버 사이드 렌더링 방식은 미리 HTML 문서를 전달하는데 이때 자바스크립트 파일을 연동시켜서 동적으로 만드는 과정을 hydration이라고 합니다. 
## SSR vs SSG vs ISR 에 대해 설명해주세요
- SSR(Server Side Rendering)
	- 클라이언트가 요청하는 시점에 서버에서 렌더링하여 클라이언트에 전달해주는 방식
- SSG(Static Site Generation)
	- **빌드 시에 모든 페이지를 미리 생성하는 방식**
	- 사이트의 내용이 변경될 때마다 새로 빌드해야 해서 실시간 업데이트는 처리 어려움
- ISR(Incremental Static Regeneration)
	- **빌드 시점에 페이지를 렌더링한 후, 설정한 시간마다 필요한 페이지를 새로 렌더링하는 방식**
	- 빌드시간 단축, 실시간 업데이트 처리가능
## SSR vs RSC (react server component)의 차이는 무엇인가요?
둘다 서버에서 렌더링을 수행하는 방식이지만, **SSR은 전체 페이지를 서버에서 렌더링**하고 **RSC는 리액트의 새로운 기능으로 서버에서 컴포넌트를 렌더링**하고 클라이언트에 전송하는 방식입니다. 
# 상태관리 라이브러리 (리덕스, 리코일, context Api 차이)
상태관리 라이브러리란 상태변화를 앱 중앙에서 관리하고 조작할 수 있는 도구입니다. 
- 리덕스
	- 액션 리듀서를 통한 명시적 업데이트
	- 코드가 복잡함 (보일러 플레이트 코드가 많음)
	- 다양한 미들웨어
- 리코일
	- 아토믹 상태관리
	- 상태를 직접 업데이트하거나 Selector 사용
- Context API
	- 리액트의 기능으로 안정적
	- 컴포넌트 중심으로 관리
	- Context Provider 를 통한 상태관리
## Flux 패턴에 대해서 알고 있나요?
Flux 패턴은 Facebook에서 개발한 상태 관리 아키텍처 패턴으로, **Actions, Dispatcher, Stores, 그리고 Views**의 네 가지 주요 구성 요소로 이루어져 있습니다. 이 패턴은 **단방향 데이터 흐름**을 제공하여 리액트 애플리케이션의 상태 관리를 더 예측 가능하고 관리하기 쉽게 만들어줍니다.
## Redux에서 액션(Action)과 리듀서(Reducer)의 역할은 무엇인가요?
리덕스에서 액션은 상태를 변경할 때 발생하는 이벤트 객체입니다. 각 액션은 타입 속성을 포함하여 어떤 종류의 변경을 요청하는지를 나타냅니다. 리듀서는 액션을 받아서 상태를 업데이트하는 함수입니다. 리듀서는 이전 상태와 액션을 인수로 받아, 새로운 상태를 반환합니다.
## 상태 관리 라이브러리가 왜 필요한가요?
애플리케이션의 규모가 커질수록 상태 관리는 점점 더 복잡해집니다. 상태 관리 라이브러리는 이러한 복잡성을 줄이고, 상태의 일관성을 유지하며, 코드의 가독성과 유지보수성을 향상시키는데 도움을 줍니다
## useContext와 useReducer가 함께 쓰였을 때의 이점은 무엇인가요?
useContext와 useReducer를 함께 사용하면, 상태 로직을 깔끔하게 분리할 수 있고 컴포넌트의 재사용성이 향상되며 유지 관리가 쉬워집니다. 

## [ 자바스크립트 ]

# Promise와 Async, Await의 차이를 설명해주세요.
Promise 는 비동기 작업을 처리하는 객체이고 Async, Await 키워드는 Promise 코드를 더 쉽고 가독성 높게 작성을 도와주는 문법입니다. 
(async 함수는 promise를 반환하고 await 은 promise 값이 반환될 때까지 promise 함수의 실행을 일시 중지합니다)
## Promise.all() 에 대해 설명해주세요.
여러 개의 Promise를 병렬적으로 처리할 때 사용하는 메서드입니다. (Promise 배열로 반환)
## 콜백이란 뭐라고 생각하나요?
함수의 매개변수를 통해 인자로 전달되는 또 다른 함수를 콜백함수라고 합니다. 
## promise의 단점을 async/await은 어떻게 보완하나요?
promise는 체이닝으로 인한 콜백 지옥과 같은 이슈가 있었는데 async/await 문법을 통해 비동기 코드의 가독성을 높혔습니다. 
## 둘 중 어느 것을 선호하시나요? 그 이유는 무엇인가요?
async/await 을 선호합니다. promise는 에러를 처리할려면 catch 메서드를 사용해야하고 코드가 복잡해지면 코드의 흐름을 쉽게 추적하기 힘듭니다. 반면 async/await 은 **가독성이 높고 try/catch 블록을 통해 쉽게 에러 처리가 가능**합니다. 
# 자바스크립트는 싱글 스레드인데 어떻게 병렬처리가 가능한가요?
자바스크립트는 싱글 스레드 언어이지만, 비동기 처리와 웹 워커를 활용하여 병렬 처리와 유사한 효과를 낼 수 있습니다.
## 콜스택과 힙에 대해 설명해주세요.
자바스크립트에서 **콜 스택은 실행 컨텍스트가 추가되고 제거되는 스택 자료구조**를 말하며, 실행 컨텍스트 스택이라고도 부릅니다. 반면에 **힙은 실행 컨텍스트가 참조할 객체를 저장하는 메모리 공간**을 지칭합니다.
## 싱글 스레드의 장단점
싱글 스레드는 한번에 한 작업만 처리함으로 더 효율적입니다. 단점으로는 긴 작업을 처리할 때 블락킹 등 퍼포먼스 문제가 있을 수 있습니다.
## 자바스크립트가 기본적으로 동작하는 방식 (webAPI, queue, event loop)을 설명해주세요.
자바스크립트는 코드를 위에서 아래로 순차적으로 실행합니다. 이때 각 함수 호출은 콜 스택에 푸시되고 함수의 실행이 완료되면 콜 스택에서 팝됩니다. 비동기 함수 실행은 메인 스레드에서 비동기 작업의 처리는 Web API를 통해 수행할 수 있습니다. 이 비동기 작업들은 메인 스레드 외부의 별도 스레드에 처리되며, 이렇게 처리된 비동기 작업의 결과는 그에 대한 콜백함수로 태스크 큐에 추가됩니다. 이벤트 루프는 콜 스택이 비었는지 확인한 후, 콜백 함수를 콜 스택으로 이동시켜 실행합니다. 태스크 큐는 순차적으로 작업을 저장하고 이벤트 루프는 콜 스택이 비었는지 태스크 큐에 처리할 작업이 있는지 계속 확인하고 콜백 함수를 콜 스택으로 이동시켜 실행합니다. 
## Web Workers에 대해서 설명해주세요
웹 워커는 브라우저에서 제공하는 API 자바스크립트를 메인 스레드 외부의 별도의 여러 스레드에 실행할 수 있게 해줍니다. 웹 워커를 사용하면 메인 스레드의 블록킹 문제를 해결할 수 있습니다.

## [ 네트워크 ]

# HTTP vs HTTPS의 차이에 대해 설명해주세요.
HTTPS는 HTTP에 보안 레이어(SSL/TLS)를 추가한 것으로, 데이터 전송의 암호화를 제공합니다.
## SSL 인증서가 무엇이고 동작하는 방식이 어떤지?
웹사이트의 신뢰성을 인증하며, 클라이언트와 서버간의 암호화된 연결을 제공합니다.
## 중간자 공격(man-in-the-middle attacks)이란 무엇이고, 어떻게 발생하며 방어할 수 있는 방법은 무엇인가요?
통신 중간에 제3자가 데이터를 도청하거나 변경하는 공격. HTTPS 사용으로 방어 가능.
## 공개키 vs 개인키 vs 비대칭키
비대칭키 암호화에서, 공개키는 암호화에, 개인키는 복호화에 사용됩니다.
## TLS와 SSL의 차이점은 무엇인가요?
TLS는 SSL의 업데이트된 버전으로, 보안 강화와 암호화 알고리즘의 개선을 제공합니다.
# TCP 3way & 4way handshaking은 무엇인가요?
- 3-way 핸드셰이킹은 연결 설정을 위해 사용되며, "SYN", "SYN-ACK", "ACK" 패킷을 주고받습니다.
- 4-way 핸드셰이킹은 연결 종료를 위해 사용되며, "FIN"과 "ACK" 패킷을 주고받아 연결을 종료합니다.
## Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도작한 상황이 발생하면?
TCP의 오류 복구 메커니즘은 지연 또는 손실된 패킷을 처리합니다. 그러나 FIN 패킷 전송에 어떻게 영향을 미치는지에 대한 구체적인 내용은 제공되지 않았습니다.
## TCP와 같은 연결 지향적 프로토콜에서 핸드쉐이크가 필요한 이유는 무엇인가요?
TCP와 같은 연결 지향 프로토콜은 데이터의 신뢰성, 순서 및 오류 확인을 보장하기 위해 핸드셰이킹이 필요합니다.
## TCP 3way & 4way handshaking이 단계가 차이나는 이유?
3-way 핸드셰이킹은 연결 설정에 중점을 두고, 4-way 핸드셰이킹은 데이터 전송 후 연결 종료에 중점을 둡니다.
## TCP와 UDP의 차이점은 무엇인가요?
- **TCP**는 연결 지향적이며 데이터의 정확한 전송을 보장합니다.
- **UDP**는 연결 없이 빠르고 간단하지만 덜 신뢰성 있습니다, 실시간 애플리케이션에 적합합니다.
