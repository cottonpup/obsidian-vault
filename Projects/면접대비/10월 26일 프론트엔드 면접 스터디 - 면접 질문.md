---
Created: 2023-10-25
tags:
---
원티드, 사람인(점핏), 로켓펀치
400개씩 
면접 12번.. (이제 안 떰)
쪼말
프로젝트 3개(1주 2개, 6주 1개)
인성쪽..
- 질문을 받았는데 모르거나 이해 x => 
	- "이해한 내용이 맞는지 한번 더 여쭤보기"
	- 말을 너무 많이 하지 않기...
- 면접 1시간 전에 가기..
- 2시간 -> 카페에서 정리
- 3시간 일찍 가기도 감.
- 자기소개 할 때 -> 
	- "안녕하세요. "
- 장점? 
	- "모르는 걸 위축되지 않음."
- 단점?
	- "업무 외 시간에 할애"
- 동료들은 너의 장단점에 대해 어떻게 생각하나?
- 3500 
	- 3800
	- 4200
	- 3600 
	- 3700 + 500 스톡 + 밥 값(만원)
	- es6, 프로미스
		- 유니콘...기업...
- 아쉽게 답변 드린게 있었는데 다시 답변 드려도 될까요?
# 10월 26일 프론트엔드 면접 스터디 - 면접 질문
## [ 리액트 ]

## 리액트에서 리스트를 구현할 때 key를 넘겨주고 있는데, 이 key를 지정해줘야 하는 이유에 대해서 설명해주실 수 있나요?
- 리액트에서 리스트를 렌더링할 때 `key` 프로퍼티를 지정하는 주된 이유는 성능 최적화 
- `key`가 있으면 리액트는 바뀐 부분만 빠르게 찾아 업데이트
### key값 설정시 주의해야 할 점이 있을까요(어떤 값을 넣으면 안된다든지)?
- `key` 값은 형제 요소 사이에서 고유
- 안정적인 값 (배열의 인덱스 x -> 변할 수 있음)
- 예약어(`key`와 같은) 피하기 
### 리액트의 key 속성은 어떻게 가상 DOM과 실제 DOM 간의 동기화를 최적화하는 데 도움을 주나요?
- `key` 속성을 통해서 어떤 컴포넌트가 수정되었는지 빠르게 파악이 가능.
- `key` 속성이 없으면 리스트의 모든 항목을 하나하나 검사해야 함.
- 필요한 부분만 실제 DOM에 업데이트가 가능. 
### reconciliation(재조정) 이란
- 리액트에서 상태나 데이터의 변화가 생길 때, UI를 어떻게 업데이트할지 결정하는 과정
- 변화가 생기면 가상 DOM 트리를 만들고, 이전 트리와 비교 (Diffing 알고리즘)
- 필요한 부분만 DOM에 업데이트를 하여 성능을 효율적으로 높힘.
### 리스트 이외에 key가 필요하거나 사용되는 곳은?
- 동적 컴포넌트 (ex. 댓글 목록)
- 조건부 렌더링 (두가지 다른 상태를 효율적으로 전환)
- 탭과 슬라이더 (복잡한 UI 구성)
	- 현재 활성화된 탭만 보여줄려면 각 탭에 `key`를 지정해서 어떤 탭이 활성화되어야 하는지 쉽게 파악
## [ 다른 사람들 답변 ]

----
#### `key`가 고유해야 하는 이유는 무엇인가요?
#### 배열 인덱스를 `key`로 사용하지 않는 이유는 무엇인가요?
#### `key` 없이도 애플리케이션은 동작하니, 실제로 얼마나 성능에 영향을 미치나요?
#### 리액트 외에 다른 프레임워크나 라이브러리에서도 비슷한 개념이 있는지 알고 있나요?
#### 성능 최적화 외에 `key`가 가지는 다른 장점이나 단점은 무엇인가요?

----
## useState의 setState가 비동기로 동작하는데 그 이유를 아시나요?
- batching 처리를 통해, `setState` 호출을 일괄적으로 처리.
	- 한 번에 UI를 업데이트하여 불필요한 연산과 렌더링을 줄이고 성능을 향상.
1. 일괄처리인데 그걸 어떻게 비동기?
	- 함수를 호출했을 때, 즉시 업데이트가 되지 않고, 리액트가 연산하여 적절한 시점에 상태를 업데이트.
### 배칭을 통해 렌더링이 한번만 일어난다고 보장할 수 있나요?
- 대부분의 경우, 한번만 일어나지만 상황에 따라 예외가 있을 수 있음
1. 예외 상황
	- `setState`가 비동기 이벤트나 프라미스의 콜백 함수 내부에서 호출되는 경우
	- `ReactDOM.flushSync`나 `ReactDOM.createBatch` 같은 API를 사용하는 경우
		- 리액트의 기본 이벤트 핸들링과 업데이트 메커니즘을 벗어난 상황에선 리액트의 batching 이 일관되게 적용되지 않음
### 비동기적으로 동작하는 setState 때문에 발생할 수 있는 문제는 무엇이며, 그것을 어떻게 해결할 수 있나요?
1. 문제점
- 상태 일관성: `setState` 빠르게 호출하면 마지막 상태만 반영된다거나 모두 동시에 반영되지 않을 수 있음.
- 최신 상태 불확실성: `setState` 후 바로 상태를 참조하면 변경되지 않은 값을 얻을 수 있음. 
	- 비동기적으로 작동하기 때문에, 일정 시간이 지나야 상태가 바뀜.

2. 해결방법
- 함수형 업데이트: `setState`안에서 이전 상태를 인자로 받고 새로운 상태로 업데이트하는 함수를 실행
- 콜백 사용: `setState`의 인자로 후처리 로직 실행하는 콜백함수를 받기
### useState 작동원리
1. `useState`가 처음 호출되면 초기 상태 값을 받아서 내부에 저장
2. 해당 컴포넌트의 리렌더링 시, `useState`는 이전에 저장한 상태 값을 반환
3. 상태를 업데이트하는 함수(예: `setCount`)가 호출되면, 새로운 상태 값이 내부에 저장
4. 상태가 변경되면, React는 컴포넌트를 다시 렌더링하도록 스케줄을 잡음

- `useState`의 최적화 원리
	- Diffing 알고리즘을 통해서 상태가 바뀌면, `render` 함수를 호출하여 변경된 부분만 실제 DOM에 반영함.
	- Batching 을 통해 여러 개의 상태를 업데이트하는 함수 호출이 있더라도 실제 DOM 업데이트는 한 번만 발생.
### react18에 도입된 automatic batching과 그 이전 버전의 batching에 대해서 설명해주세요.
1. React 17 이하: 이벤트 핸들러, 생명주기 메서드 내 자동으로 배치처리
2. React 18: Automatic Batching, 비동기 코드, setTimeout과 같은 타이머 함수에서도 적용
	- Concurrent Mode: React 18의 새로운 기능, 더 효율적인 UI 업데이트
	- 비동기 코드 내부에서도 일관된 배치 처리가 가능
		- 성능이 더 향상되고 코드의 예측 가능성이 높아짐
---
## [ 다른 사람들 답변 ]

----

## [ 자바스크립트 ]

## 실행 컨텍스트에 대해서 설명해주세요.
- 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 실행 순서, 결과를 실제로 관리하는 영역
- 코드가 실행될 때마다 새로운 컨텍스트가 생김
- 렉시컬 환경, 변수 환경, this 바인딩이 정해짐
### 스코프체인이란 무엇인가요?
- 스코프가 계층적으로 연결된 것을 스코프체인이라고 함
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해, 상위 스코프로 이동해가면서 검색
### 실행 컨텍스트의 생성 및 관리 과정에서 호이스팅이란 무엇이며, 그것이 발생하는 원인은 무엇인가요?
- 변수와 함수 선언이 해당 스코프의 최상단으로 끌어올려지는 것
- 컴파일 과정을 먼저 거친 후, 변수, 함수 선언이 메모리에 할당되고, 실제 코드 실행은 나중에
- 코드 실행 전, 변수는 메모리에 undefined로 함수는 전체함수코드(함수코드 전체)로 초기화
	- 이로 인해 선언전에도 변수와 함수에 접근이 가능
### 렉시컬 스코프(정적 스코프)에 대해 설명해주세요 
- 스코프가 코드가 정의된 '위치'에 따라 접근 변수에 대한 범위를 정적으로 결정
	- 어디에서 호출되는 지랑은 상관없음 (이건 동적 스코프)
- 함수의 상위 스코프는 언제나 자신이 정의된 스코프
### 클로저란 무엇인가요?
- 내부 함수가 외부 함수의 변수에 접근 가능
- 데이터 은닉, 동적 함수 생성 등에 사용
---
## [ 다른 사람들 답변 ]

---
## 이벤트 버블링과 이벤트 캡처링의 차이는 무엇인가요?
- 버블링: 이벤트가 발생한 요소부터 부모 요소로 전파 (기본적으로 일어남)
- 캡처링: 부모 요소부터 이벤트가 발생한 요소까지 전파
### 이벤트 전파를 방지하는 방법에 대해 말씀해주세요
- `event.stopPropagation()`: 캡처링과 버블링을 모두 멈춤
- `event.preventDefault()`: 기본 동작만 막음
### 이벤트 버블링과 이벤트 캡처링이 발생하는 구체적인 단계나 순서는 어떻게 되나요?
버블링: 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다.
- 캡처링:
	1. 최상위 조상 요소에서 이벤트 시작 (예: `window` 또는 `document`)
	2. 타깃 요소까지 이벤트를 전파
	3. 타깃 요소에 도달하면, 이벤트 버블링이 시작됨
- 캡처링 단계에서는 일반적으로 이벤트 핸들러가 실행되지 않음 
- 명시적으로 이벤트 리스너를 추가할 때 세 번째 인자로 `true`를 전달함으로써 실행가능

- 버블링: 
	1. 내부 요소에서 이벤트 발생 (예: 버튼 클릭)
	2. 해당 요소의 이벤트 핸들러 실행 (버튼의 클릭 이벤트 핸들러)
	3. 부모 요소로 이벤트 전파 (예: 버튼 -> 폼 -> div -> body -> document)
	4. 각 부모 요소의 이벤트 핸들러 실행 (폼의 클릭 이벤트 핸들러, div의 클릭 이벤트 핸들러 등)
### 이벤트 위임에 대해 설명해주세요
- 이벤트 위임이란 하위 요소마다 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식
- `event.target`을 사용해 실제 발생한 요소 판별
### even.target과 event.current의 차이는 무엇인가요?
- `event.target`: 실제 이벤트가 발생한 요소
- `event.currentTarget`: 이벤트 리스너가 붙어있는 요소 (= `this`)
---
## [ 다른 사람들 답변 ]

---
## [ 네트워크 ] 

## TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol) 차이점
- TCP: 신뢰성, 연결 지향, 데이터 순서 보장
- UDP: 신뢰성 없음, 연결 없음, 빠른 전송
### 각각 언제 사용하는 것이 유용한가요?(예시)
- TCP: 파일 전송, 이메일, 웹 브라우징
- UDP: 스트리밍, 실시간 게임
### TCP와 UDP 각각에서 헤더의 크기와 구성이 어떻게 다른가요?
- TCP: 더 크고 복잡 (20~60바이트)
- UDP: 작고 단순 (8바이트)
### 3-way handshaking에 대해 설명해주세요
SYN -> SYN/ACK -> ACK 순으로 패킷 교환하여 연결 확립
### HTTP 버전별 둘 중에 어떤 것을 사용하고 왜 변경되고 있는지?
- HTTP/1.x: TCP
- HTTP/2, HTTP/3: TCP, UDP (QUIC)
---
## [ 다른 사람들 답변 ]

---
## RESTFUL 개발이란?
RESTful 개발은 URI로 리소스를 식별하고 표준 HTTP 메서드로 상호작용하는 설계 방식입니다. 
- 각 요청이 독립적으로 처리되어 서버는 상태를 저장하지 않음
- HTTP 프로토콜의 캐시 기능을 활용가능
- 확장성이 좋음
	- 컴포넌트가 독립적으로 동작하기 때문에, 새로운 리소스나 서비스를 추가하거나 기존 리소스를 수정하는 것이 상대적으로 쉬움
### HTTP 메서드의 각각의 역할을 설명해주세요.
HTTP 메서드는 클라이언트가 서버에게 요청의 종류와 목적을 알리는 방법. 
- GET: 데이터 조회
- POST: 데이터 생성
- PUT: 데이터 수정
- PATCH: 데이터 일부 수정
- DELETE: 데이터 삭제
### RESTFUL 서비스는 상태가 없다(stateless)는 의미는 무엇이며, 이러한 특성이 서비스 설계에 어떤 장점을 가져다 주나요?
- 각 요청이 클라이언트와 서버 간의 상호작용이 독립적으로 처리됨
- 장점: 
	- 확장성
		- 독립적이라 시스템 확장이 쉬움
	- 단순성
		- 상태정보를 유지하지 않아도 되므로 서버설계가 단순
	- 캐싱
		- 결과를 캐싱하기 쉬움
		- 클라이언트가 상태를 관리 하므로!
	- 상태관리 부담적음
		- 클라이언트 측에서 상태를 관리하므로 서버의 부담이 적음
### 알고계신 오류코드를 설명해주세요
- 404: Not Found
	- 요청한 리소스를 서버에서 찾을 수 없는 경우
	- 잘못된 URL을 요청하거나 삭제된 페이지
- 500: Internal Server Error
	- 서버에서 발생한 내부 오류로 클라이언트 요청을 처리할 수 없는 경우
	- 예상치 못한 오류가 발생했거나, 서버 구성의 문제
- 403: Forbidden
	- 요청한 리소스에 대한 접근 권한이 없을 때
	- 인증되지 않은 사용자가 보호된 페이지에 접근하려고 할 때
### preflight request가 필요한 요청에는 어떤 것이 있나요?
Preflight request는 보안상의 이유로, 실제 요청을 보내기 전에 브라우저가 자동으로 서버에 보내는 예비 요청
- CORS 상황에서 `PUT`, `DELETE` 등의 메서드 
- 특정 커스텀 헤더 사용 시
- `Content-Type` 헤더가 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 이외의 값을 가지는 경우.
위 상황에서는 OPTIONS 메서드를 사용한 preflight request를 서버에 보냅니다. 
---
## [ 다른 사람들 답변 ]

---

## html - 랜덤
##

---
# References
1. 